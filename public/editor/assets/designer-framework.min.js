/*
 PlayCanvas Designer Framework
 http://playcanvas.com
 Copyright 2011-2013 PlayCanvas Ltd. All rights reserved.
 Do not distribute.
*/
pc.designer = pc.designer || {};
pc.extend(pc.designer, function() {
  var Designer = function(canvas, options) {
    var gizmo;
    this._inTools = true;
    gizmo = new pc.designer.GizmoComponentSystem(this.context);
    for(var key in this.context.systems) {
      if(this.context.systems.hasOwnProperty(key)) {
        this.context.systems[key]._inTools = true
      }
    }
    this.context.designer = {livelink:this._link, selection:[]};
    this.grid = new pc.designer.graphics.Grid(this.graphicsDevice);
    this.context.scene.addModel(this.grid.model);
    this.designerSettings = null;
    this.designerCamerasPath = "Designer/Local/Designer/";
    this.viewCube = new pc.designer.graphics.ViewCube(this.graphicsDevice);
    this.quadView = {bottomLeft:{cameraName:this.designerCamerasPath + "Left", shading:pc.scene.RENDERSTYLE_SOLID, picker:new pc.scene.Picker(this.graphicsDevice, 1, 1)}, bottomRight:{cameraName:this.designerCamerasPath + "Perspective", shading:pc.scene.RENDERSTYLE_SOLID, picker:new pc.scene.Picker(this.graphicsDevice, 1, 1)}, topLeft:{cameraName:this.designerCamerasPath + "Top", shading:pc.scene.RENDERSTYLE_SOLID, picker:new pc.scene.Picker(this.graphicsDevice, 1, 1)}, topRight:{cameraName:this.designerCamerasPath +
    "Front", shading:pc.scene.RENDERSTYLE_SOLID, picker:new pc.scene.Picker(this.graphicsDevice, 1, 1)}};
    this.activeViewport = {};
    this.activeCameraEntity = null;
    this.setActiveViewport("bottomRight");
    this.setActiveViewportMaximized(true);
    this.redraw = true;
    this.lastMouseEvent = null
  };
  Designer = pc.inherits(Designer, pc.fw.Application);
  Designer.prototype.init = function() {
  };
  Designer.prototype.getCamera = function(pathOrGuid) {
    return this.context.root.findByPath(pathOrGuid) || this.context.root.findByGuid(pathOrGuid)
  };
  Designer.prototype.render = function() {
    var self = this;
    var context = this.context;
    var renderer = this.renderer;
    var root = context.root;
    context.root.syncHierarchy();
    var device = this.graphicsDevice;
    var dw = device.width;
    var dh = device.height;
    device.setRenderTarget(null);
    device.updateBegin();
    device.setViewport(0, 0, dw, dh);
    device.setScissor(0, 0, dw, dh);
    device.clear({color:[0.5, 0.5, 0.5, 1], flags:pc.gfx.CLEARFLAG_COLOR});
    device.updateEnd();
    var setRenderStyle = function(style) {
      var drawCalls = context.scene.drawCalls;
      for(var i = 0;i < drawCalls.length;i++) {
        if(!drawCalls[i].command) {
          var meshInstance = drawCalls[i];
          if(typeof meshInstance.mesh.primitive[style] !== "undefined") {
            meshInstance.renderStyle = style
          }
        }
      }
    };
    var renderViewport = function(viewport, active) {
      var cameraEntity = self.getCamera(viewport.cameraName);
      if(cameraEntity) {
        if(active) {
          var avp = this.quadView[this.activeViewport.name].viewport;
          device.setRenderTarget(null);
          device.updateBegin();
          device.setViewport(avp.x - 1, avp.y - 1, avp.width + 2, avp.height + 2);
          device.setScissor(avp.x - 1, avp.y - 1, avp.width + 2, avp.height + 2);
          device.clear({color:[1, 1, 0, 1], flags:pc.gfx.CLEARFLAG_COLOR});
          device.updateEnd()
        }
        var camera = cameraEntity.camera.camera;
        camera.setRenderTarget(null);
        var isDesignerCamera = pc.string.startsWith(cameraEntity.getPath(), this.designerCamerasPath);
        if(this.designerSettings && isDesignerCamera) {
          var clearColor = this.designerSettings.camera_clear_color;
          cameraEntity.camera.clearColor = new pc.Color(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
          cameraEntity.camera.nearClip = this.designerSettings.camera_near_clip;
          cameraEntity.camera.farClip = this.designerSettings.camera_far_clip
        }
        var vp = viewport.viewport;
        camera.setRect(vp.x / dw, vp.y / dh, vp.width / dw, vp.height / dh);
        cameraEntity.camera.frameBegin();
        setRenderStyle(viewport.shading);
        renderer.render(context.scene, camera);
        cameraEntity.camera.frameEnd()
      }
    }.bind(this);
    if(this.activeViewport.maximized) {
      var viewport = this.quadView[this.activeViewport.name];
      renderViewport(viewport, true)
    }else {
      for(var viewportName in this.quadView) {
        var viewport = this.quadView[viewportName];
        renderViewport(viewport, viewportName === this.activeViewport.name)
      }
    }
  };
  Designer.prototype.tick = function() {
    if(this.redraw) {
      if(this.lastMouseEvent) {
        this.context.systems.gizmo.handleMouseMove(this.lastMouseEvent);
        this.lastMouseEvent = null
      }
      pc.fw.ComponentSystem.update(0, this.context, true);
      this.render();
      this.redraw = false
    }
    requestAnimationFrame(this.tick.bind(this), this.canvas)
  }, Designer.prototype.updateViewports = function() {
    var w = this.graphicsDevice.width;
    var h = this.graphicsDevice.height;
    var halfWidth = Math.floor(w / 2);
    var halfHeight = Math.floor(h / 2);
    this.quadView["bottomLeft"].viewport = {x:0, y:0, width:halfWidth, height:halfHeight};
    this.quadView["bottomRight"].viewport = {x:halfWidth, y:0, width:w - halfWidth, height:halfHeight};
    this.quadView["topLeft"].viewport = {x:0, y:halfHeight, width:halfWidth, height:h - halfHeight};
    this.quadView["topRight"].viewport = {x:halfWidth, y:halfHeight, width:w - halfWidth, height:h - halfHeight};
    if(this.activeViewport.maximized) {
      this.quadView[this.activeViewport.name].viewport = {x:0, y:0, width:w, height:h}
    }
    for(var viewportName in this.quadView) {
      var viewport = this.quadView[viewportName];
      if(viewport.viewport.width > 4) {
        viewport.viewport.x += 2;
        viewport.viewport.width -= 4
      }
      if(viewport.viewport.height > 4) {
        viewport.viewport.y += 2;
        viewport.viewport.height -= 4
      }
      viewport.picker.resize(viewport.viewport.width, viewport.viewport.height)
    }
  };
  Designer.prototype.resize = function(w, h) {
    this.updateViewports()
  };
  Designer.prototype.setActiveViewportMaximized = function(maximized) {
    this.activeViewport.maximized = maximized;
    this.updateViewports();
    this.setActiveViewport(this.activeViewport.name)
  };
  Designer.prototype.setActiveViewportShading = function(mode) {
    this.quadView[this.activeViewport.name].shading = mode
  };
  Designer.prototype._deactivateCurrentCamera = function() {
    if(this.activeViewport.name) {
      var cameraName = this.quadView[this.activeViewport.name].cameraName;
      var cameraEntity = this.getCamera(cameraName);
      if(cameraEntity && cameraEntity.script) {
        this.context.systems.script.removeComponent(cameraEntity)
      }
    }
  };
  Designer.prototype._activateCamera = function() {
    var cameraName = this.quadView[this.activeViewport.name].cameraName;
    var cameraEntity = this.getCamera(cameraName);
    if(cameraEntity) {
      this.activeCameraEntity = cameraEntity;
      if(cameraEntity.script && !cameraEntity.script.designer_camera) {
        this.context.systems.script.removeComponent(cameraEntity)
      }
      if(!cameraEntity.script) {
        this.context.systems.script.addComponent(cameraEntity, {scripts:[{url:"/script/scripts/designer_camera.js"}], runInTools:true})
      }
      this.context.systems.gizmo.setCamera(cameraEntity);
      pc.designer.api.setActiveViewportCamera(cameraName)
    }
  };
  Designer.prototype.setActiveViewportCamera = function(cameraName) {
    this._deactivateCurrentCamera();
    this.quadView[this.activeViewport.name].cameraName = cameraName;
    this._activateCamera()
  };
  Designer.prototype.setActiveViewport = function(viewportName) {
    this._deactivateCurrentCamera();
    this.activeViewport.name = viewportName;
    this._activateCamera()
  };
  Designer.prototype.setActiveGizmoType = function(gizmoType) {
    this.context.systems.gizmo.setCurrentGizmoType(gizmoType)
  };
  Designer.prototype.setActiveGizmoCoordSys = function(coordSys) {
    this.context.systems.gizmo.setCurrentGizmoCoordSys(coordSys)
  };
  Designer.prototype.setSnapToClosestIncrement = function(snap) {
    this.context.systems.gizmo.setSnapToClosestIncrement(snap)
  };
  Designer.prototype.setDesignerSettings = function(settings) {
    this.designerSettings = settings;
    this.context.systems.gizmo.setTranslationSnapIncrement(settings.snap_increment);
    this.context.systems.gizmo.setScalingSnapIncrement(settings.snap_increment);
    if(this.grid) {
      this.context.scene.removeModel(this.grid.model);
      this.grid.destroy();
      this.grid = new pc.designer.graphics.Grid(this.graphicsDevice, settings.grid_divisions * settings.grid_division_size, settings.grid_divisions);
      this.context.scene.addModel(this.grid.model)
    }
  };
  Designer.prototype.select = function(entities) {
    var index, length = entities.length;
    var selection = [];
    for(index = 0;index < length;index++) {
      var e = this.context.root.findByGuid(entities[index]);
      if(e) {
        selection.push(e)
      }
    }
    if(!pc.config.readOnly) {
      this.context.systems.gizmo.setSelection(selection)
    }
    this.context.designer.selection = selection
  };
  Designer.prototype.frameSelection = function() {
    var cameraName = this.quadView[this.activeViewport.name].cameraName;
    var cameraEntity = this.getCamera(cameraName);
    if(cameraEntity && cameraEntity.script) {
      cameraEntity.script.send("designer_camera", "frameSelection")
    }
  };
  Designer.prototype.handleMouseDown = function(event) {
    event.preventDefault();
    var e = new pc.input.MouseEvent(this.context.mouse, event);
    var x = e.x;
    var y = e.y;
    if(!this.activeViewport.maximized) {
      var pickedViewport;
      if(x < this.canvas.width / 2) {
        if(y < this.canvas.height / 2) {
          pickedViewport = "topLeft"
        }else {
          pickedViewport = "bottomLeft"
        }
      }else {
        if(y < this.canvas.height / 2) {
          pickedViewport = "topRight"
        }else {
          pickedViewport = "bottomRight"
        }
      }
      if(this.activeViewport.name !== pickedViewport) {
        this.setActiveViewport(pickedViewport)
      }
    }
    if(!e.altKey) {
      this.context.systems.gizmo.handleMouseDown(e);
      if(!this.context.systems.gizmo.draggingState) {
        var activeViewport = this.quadView[this.activeViewport.name];
        var vp = activeViewport.viewport;
        var pickCoord = {x:x - vp.x, y:this.canvas.height - y - vp.y};
        var picker = activeViewport.picker;
        var cameraEntity = this.getCamera(activeViewport.cameraName);
        if(!cameraEntity) {
          return
        }
        picker.prepare(cameraEntity.camera.camera, this.context.scene);
        var picked = picker.getSelection(pickCoord);
        if(picked.length > 0) {
          var selectedNode = picked[0].node;
          while(!(selectedNode instanceof pc.fw.Entity) && selectedNode !== null) {
            selectedNode = selectedNode.getParent()
          }
          if(selectedNode) {
            if(e.button !== pc.input.MOUSEBUTTON_RIGHT) {
              if(this.context.designer.selection.indexOf(selectedNode) < 0) {
                pc.designer.api.setEntitySelection([selectedNode.getGuid()])
              }else {
                var meshSelection = this._getMeshInstanceSelection(selectedNode, picked);
                if(meshSelection) {
                  pc.designer.api.setMeshInstanceSelection(meshSelection.model, meshSelection.material, meshSelection.meshInstanceIndex, meshSelection.entityId)
                }
              }
            }else {
              pc.designer.api.setEntitySelection([selectedNode.getGuid()]);
              var meshSelection = this._getMeshInstanceSelection(selectedNode, picked);
              if(meshSelection) {
                pc.designer.api.setContextMeshInstanceSelection(meshSelection.model, meshSelection.material, meshSelection.meshInstanceIndex, meshSelection.entityId)
              }
            }
          }
        }else {
          pc.designer.api.clearSelection()
        }
      }
    }
  };
  Designer.prototype._getMeshInstanceSelection = function(selectedNode, pickedInstances) {
    var result = null;
    if(selectedNode.model && selectedNode.model.model) {
      var meshInstances = selectedNode.model.model.meshInstances;
      for(var i = 0;i < meshInstances.length;i++) {
        var instance = meshInstances[i];
        if(instance === pickedInstances[0]) {
          var materialId = null;
          if(selectedNode.model.type === "asset") {
            var modelAsset = this.context.assets.getAssetById(selectedNode.model.asset);
            if(modelAsset.data.mapping) {
              materialId = modelAsset.data.mapping[i].material
            }
            result = {model:selectedNode.model.asset, material:materialId, meshInstanceIndex:i, entityId:selectedNode.getGuid()}
          }else {
            result = {model:null, material:selectedNode.model.data.materialAsset, meshInstanceIndex:i, entityId:selectedNode.getGuid()}
          }
          break
        }
      }
    }
    return result
  };
  Designer.prototype.handleMouseUp = function(event) {
    var e = new pc.input.MouseEvent(this.context.mouse, event);
    this.context.systems.gizmo.handleMouseUp(e)
  };
  Designer.prototype.handleMouseMove = function(event) {
    this.lastMouseEvent = new pc.input.MouseEvent(this.context.mouse, event)
  };
  Designer.prototype._handleMessage = function(msg) {
    pc.designer.Designer._super._handleMessage.call(this, msg);
    switch(msg.type) {
      case pc.fw.LiveLinkMessageType.UPDATE_ENTITY_TRANSFORM:
        var entity = this.context.root.findByGuid(msg.content.id);
        if(entity) {
          entity._$position = msg.content.position;
          entity._$rotation = msg.content.rotation;
          entity._$scale = msg.content.scale
        }
        break;
      case pc.fw.LiveLinkMessageType.OPEN_PACK:
        var patch = function(entity, data) {
          if(entity) {
            entity._$position = data["position"];
            entity._$rotation = data["rotation"];
            entity._$scale = data["scale"]
          }
          var i, entities = entity.getChildren();
          var children = data["children"];
          var len = children.length;
          for(i = 0;i < len;i++) {
            patch(entities[i], children[i])
          }
        };
        var root = this.context.root.findByGuid(msg.content.pack.hierarchy["resource_id"]);
        patch(root, msg.content.pack.hierarchy);
        this._linkUpdatePackSettings(msg.content.pack.settings);
        break;
      case pc.fw.LiveLinkMessageType.OPEN_ENTITY:
        if(msg.content.entity) {
          var patch = function(entity, data) {
            if(entity) {
              entity._$position = data["position"];
              entity._$rotation = data["rotation"];
              entity._$scale = data["scale"]
            }
            var i, entities = entity.getChildren();
            var children = data["children"];
            var len = children.length;
            for(i = 0;i < len;i++) {
              patch(entities[i], children[i])
            }
          };
          var root = this.context.root.findByGuid(msg.content.entity["resource_id"]);
          patch(root, msg.content.entity)
        }else {
          var models = msg.content.models;
          if(!models) {
            models = [msg.content.model]
          }
          var i, len = models.length;
          for(i = 0;i < len;i++) {
            var entity = this.context.root.findByGuid(models[i]["resource_id"]);
            if(entity) {
              entity._$position = models[i]["position"];
              entity._$rotation = models[i]["rotation"];
              entity._$scale = models[i]["scale"]
            }
          }
        }
        break;
      case pc.fw.LiveLinkMessageType.CLOSE_ENTITY:
        var cameraEntity = this.getCamera(this.quadView[this.activeViewport.name].cameraName);
        if(!cameraEntity) {
          this.setActiveViewportCamera(this.designerCamerasPath + "Perspective")
        }
        break;
      case pc.fw.LiveLinkMessageType.REPARENT_ENTITY:
        if(this.activeCameraEntity && this.activeCameraEntity.getGuid() === msg.content.id) {
          var newPath = this.context.root.findByGuid(msg.content.id).getPath();
          this.setActiveViewportCamera(newPath)
        }
        break;
      case pc.fw.LiveLinkMessageType.UPDATE_COMPONENT:
        if(this.activeCameraEntity && this.activeCameraEntity.getGuid() === msg.content.id && msg.content.component === "script") {
          this._activateCamera()
        }
        break;
      case pc.fw.LiveLinkMessageType.SELECTION_UPDATED:
        this.select(msg.content.guids);
        break;
      case pc.fw.LiveLinkMessageType.UPDATE_ASSETCACHE:
        break;
      case pc.fw.LiveLinkMessageType.UPDATE_DESIGNER_SETTINGS:
        this.setDesignerSettings(msg.content.settings);
        break
    }
  };
  return{user:null, owner:null, depot:null, Designer:Designer}
}());pc.extend(pc.fw, function() {
  var DesignerInterface = function(view) {
    this.view = view
  };
  DesignerInterface.prototype = {setEntityTransformComponent:function(entity, type, newVal, undoable, oldVal) {
    var resource_id = entity.getGuid();
    if(newVal) {
      newVal = pc.makeArray(newVal.data)
    }
    if(oldVal) {
      oldVal = pc.makeArray(oldVal.data)
    }
    this.view.fireEvent("entitytransformchanged", resource_id, type, newVal, undoable, oldVal)
  }, setCameraTransformComponent:function(entity, type, newVal, undoable, oldVal) {
    var resource_id = entity.getGuid();
    if(newVal) {
      newVal = pc.makeArray(newVal.data)
    }
    if(oldVal) {
      oldVal = pc.makeArray(oldVal.data)
    }
    this.view.fireEvent("cameratransformchanged", resource_id, type, newVal, undoable, oldVal)
  }, setCameraViewWindowSize:function(entity, newX, newY) {
    var resource_id = entity.getGuid();
    this.view.fireEvent("cameraviewwindowchanged", resource_id, newX, newY)
  }, setActiveViewportCamera:function(cameraPath) {
    this.view.fireEvent("activecamerachanged", cameraPath)
  }, setSelection:function(resourceIds) {
    var entities = Ext.getStore("Entities");
    var assets = Ext.getStore("Assets");
    var records = resourceIds.map(function(resourceId) {
      var record = entities.getNodeById(resourceId);
      if(!record) {
        record = assets.getById(resourceId)
      }
      return PCD.model.Selection.create(record)
    });
    this.view.fireEvent("select", this.view, records)
  }, setEntitySelection:function(entities) {
    var store = Ext.getStore("Entities");
    var i, length = entities.length;
    var records = [];
    for(i = 0;i < length;i++) {
      records.push(PCD.model.Selection.create(store.getNodeById(entities[i])))
    }
    this.view.fireEvent("select", this.view, records)
  }, setAssetSelection:function(assets) {
    var store = Ext.getStore("Assets");
    var records = assets.map(function(asset) {
      return PCD.model.Selection.create(store.getById(asset))
    });
    this.view.fireEvent("select", this.view, records)
  }, setContextMeshInstanceSelection:function(model, material, meshInstanceIndex, entityId) {
    this.view.fireEvent("contextmeshselect", model, material, meshInstanceIndex, entityId)
  }, setMeshInstanceSelection:function(model, material, meshInstanceIndex, entityId) {
    var selection = Ext.create("PCD.model.MeshInstance", {modelId:model, materialId:material, meshInstanceIndex:meshInstanceIndex, entityId:entityId});
    this.view.fireEvent("select", this.view, [PCD.model.Selection.create(selection)])
  }, clearSelection:function() {
    this.view.fireEvent("select", this.view, [])
  }};
  return{DesignerInterface:DesignerInterface}
}());pc.designer.graphics = {};pc.extend(pc.designer.graphics, function() {
  var MULTIAXIS_PLANESIZE = 0.4;
  var Gizmo = function Gizmo(context) {
    this.context = context;
    var device = context.graphicsDevice;
    this.currentGizmo = -1;
    var red = new pc.scene.BasicMaterial;
    red.color = new pc.Color(1, 0, 0, 1);
    red.cull = pc.gfx.CULLFACE_NONE;
    red.update();
    var green = new pc.scene.BasicMaterial;
    green.color = new pc.Color(0, 1, 0, 1);
    green.cull = pc.gfx.CULLFACE_NONE;
    green.update();
    var blue = new pc.scene.BasicMaterial;
    blue.color = new pc.Color(0, 0, 1, 1);
    blue.cull = pc.gfx.CULLFACE_NONE;
    blue.update();
    var yellow = new pc.scene.BasicMaterial;
    yellow.color = new pc.Color(1, 1, 0, 1);
    yellow.cull = pc.gfx.CULLFACE_NONE;
    yellow.update();
    var transparent_yellow = new pc.scene.BasicMaterial;
    transparent_yellow.color = new pc.Color(1, 1, 0, 0.5);
    transparent_yellow.cull = pc.gfx.CULLFACE_NONE;
    transparent_yellow.blendType = pc.scene.BLEND_NORMAL;
    transparent_yellow.depthTest = false;
    transparent_yellow.depthWrite = false;
    transparent_yellow.update();
    var transparent_red = new pc.scene.BasicMaterial;
    transparent_red.color = new pc.Color(1, 0, 0, 0.3);
    transparent_red.blend = true;
    transparent_red.blendSrc = pc.gfx.BLENDMODE_SRC_ALPHA;
    transparent_red.blendDst = pc.gfx.BLENDMODE_ONE_MINUS_SRC_ALPHA;
    transparent_red.cull = pc.gfx.CULLFACE_NONE;
    transparent_red.depthTest = false;
    transparent_red.depthWrite = false;
    transparent_red.update();
    var transparent_green = new pc.scene.BasicMaterial;
    transparent_green.color = new pc.Color(0, 1, 0, 0.3);
    transparent_green.blend = true;
    transparent_green.blendSrc = pc.gfx.BLENDMODE_SRC_ALPHA;
    transparent_green.blendDst = pc.gfx.BLENDMODE_ONE_MINUS_SRC_ALPHA;
    transparent_green.cull = pc.gfx.CULLFACE_NONE;
    transparent_green.depthTest = false;
    transparent_green.depthWrite = false;
    transparent_green.update();
    var transparent_blue = new pc.scene.BasicMaterial;
    transparent_blue.color = new pc.Color(0, 0, 1, 0.3);
    transparent_blue.blend = true;
    transparent_blue.blendSrc = pc.gfx.BLENDMODE_SRC_ALPHA;
    transparent_blue.blendDst = pc.gfx.BLENDMODE_ONE_MINUS_SRC_ALPHA;
    transparent_blue.cull = pc.gfx.CULLFACE_NONE;
    transparent_blue.depthTest = false;
    transparent_blue.depthWrite = false;
    transparent_blue.update();
    var transparent_white = new pc.scene.BasicMaterial;
    transparent_white.color = new pc.Color(1, 1, 1, 0.3);
    transparent_white.blend = true;
    transparent_white.blendSrc = pc.gfx.BLENDMODE_SRC_ALPHA;
    transparent_white.blendDst = pc.gfx.BLENDMODE_ONE_MINUS_SRC_ALPHA;
    transparent_white.cull = pc.gfx.CULLFACE_NONE;
    transparent_white.depthTest = false;
    transparent_white.depthWrite = false;
    transparent_white.update();
    var blocker = new pc.scene.BasicMaterial;
    blocker.redWrite = false;
    blocker.greenWrite = false;
    blocker.blueWrite = false;
    blocker.alphaWrite = false;
    blocker.update();
    var invisible = new pc.scene.BasicMaterial;
    invisible.color = new pc.Color(0, 0, 0, 0);
    invisible.blend = true;
    invisible.blendSrc = pc.gfx.BLENDMODE_SRC_ALPHA;
    invisible.blendDst = pc.gfx.BLENDMODE_ONE_MINUS_SRC_ALPHA;
    invisible.depthTest = false;
    invisible.depthWrite = false;
    invisible.update();
    this.axisMaterials = [red, green, blue];
    this.selectedMaterials = [];
    this.selectedMaterials[pc.designer.graphics.GizmoMode.ROTATE] = [yellow, yellow, yellow];
    this.selectedMaterials[pc.designer.graphics.GizmoMode.TRANSLATE] = [yellow, yellow, yellow, transparent_yellow, transparent_yellow, transparent_yellow, yellow, yellow, yellow];
    this.selectedMaterials[pc.designer.graphics.GizmoMode.SCALE] = [yellow, yellow, yellow, transparent_yellow, yellow, yellow, yellow];
    this.blockerMaterial = blocker;
    this.invisibleMaterial = invisible;
    this.vertexFormat = new pc.gfx.VertexFormat(device, [{semantic:pc.gfx.SEMANTIC_POSITION, components:3, type:pc.gfx.ELEMENTTYPE_FLOAT32}]);
    this.gizmoMaterials = [];
    this.gizmoMaterials[pc.designer.graphics.GizmoMode.ROTATE] = this.axisMaterials;
    this.gizmoMaterials[pc.designer.graphics.GizmoMode.TRANSLATE] = [red, green, blue, transparent_blue, transparent_red, transparent_green, red, green, blue];
    this.gizmoMaterials[pc.designer.graphics.GizmoMode.SCALE] = [red, green, blue, transparent_white, red, green, blue];
    this.gizmos = [];
    this.gizmos[pc.designer.graphics.GizmoMode.ROTATE] = this.createRotateGizmo();
    this.gizmos[pc.designer.graphics.GizmoMode.TRANSLATE] = this.createTranslateGizmo();
    this.gizmos[pc.designer.graphics.GizmoMode.SCALE] = this.createScaleGizmo();
    this.renders = [];
    this.renders[pc.designer.graphics.GizmoMode.ROTATE] = this._renderRotateGizmo;
    this.renders[pc.designer.graphics.GizmoMode.TRANSLATE] = this._renderTranslateGizmo;
    this.renders[pc.designer.graphics.GizmoMode.SCALE] = this._renderScaleGizmo;
    var clearOptions = {flags:pc.gfx.CLEARFLAG_DEPTH};
    var command = new pc.scene.Command(pc.scene.LAYER_GIZMO, pc.scene.BLEND_NONE, function() {
      device.clear(clearOptions)
    });
    context.scene.drawCalls.push(command)
  };
  Gizmo.prototype = {createAxes:function(node) {
    var device = this.context.graphicsDevice;
    var vertexBuffer = new pc.gfx.VertexBuffer(device, this.vertexFormat, 6);
    var vertexData = new Float32Array(vertexBuffer.lock());
    vertexData.set([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1]);
    vertexBuffer.unlock();
    var meshInstances = [];
    for(var axis = 0;axis < 3;axis++) {
      var mesh = new pc.scene.Mesh;
      mesh.vertexBuffer = vertexBuffer;
      mesh.indexBuffer[0] = null;
      mesh.primitive[0].type = pc.gfx.PRIMITIVE_LINES;
      mesh.primitive[0].base = axis * 2;
      mesh.primitive[0].count = 2;
      mesh.primitive[0].indexed = false;
      var meshInstance = new pc.scene.MeshInstance(node, mesh, this.axisMaterials[axis]);
      meshInstance.layer = pc.scene.LAYER_GIZMO;
      meshInstance.updateKey();
      meshInstances.push(meshInstance)
    }
    return meshInstances
  }, createRotateGizmo:function() {
    var device = this.context.graphicsDevice;
    var axisSegments = 50;
    var numVerts = axisSegments + 1;
    var angle = 0;
    var iterator;
    var vertexBuffers = [];
    for(var axis = 0;axis <= 3;axis++) {
      vertexBuffers.push(new pc.gfx.VertexBuffer(device, this.vertexFormat, numVerts));
      iterator = new pc.gfx.VertexIterator(vertexBuffers[axis]);
      for(var seg = 0;seg <= axisSegments;seg++) {
        angle = 2 * Math.PI * (seg / axisSegments);
        sinAngle = Math.sin(angle);
        cosAngle = Math.cos(angle);
        if(axis === 0) {
          iterator.element[pc.gfx.SEMANTIC_POSITION].set(0, sinAngle, cosAngle)
        }else {
          if(axis === 1) {
            iterator.element[pc.gfx.SEMANTIC_POSITION].set(sinAngle, 0, cosAngle)
          }else {
            if(axis === 2) {
              iterator.element[pc.gfx.SEMANTIC_POSITION].set(sinAngle, cosAngle, 0)
            }
          }
        }
        iterator.next()
      }
      iterator.end()
    }
    var node = new pc.scene.GraphNode;
    var mesh, meshInstance;
    var meshInstances = [];
    var materials = this.gizmoMaterials[pc.designer.graphics.GizmoMode.ROTATE];
    for(var i = 0;i < 3;i++) {
      mesh = new pc.scene.Mesh;
      mesh.vertexBuffer = vertexBuffers[i];
      mesh.indexBuffer[0] = null;
      mesh.primitive[0].type = pc.gfx.PRIMITIVE_LINESTRIP;
      mesh.primitive[0].base = 0;
      mesh.primitive[0].count = vertexBuffers[i].getNumVertices();
      mesh.primitive[0].indexed = false;
      meshInstance = new pc.scene.MeshInstance(node, mesh, materials[i]);
      meshInstance.layer = pc.scene.LAYER_GIZMO;
      meshInstance.updateKey();
      meshInstances.push(meshInstance)
    }
    mesh = pc.scene.procedural.createSphere(device, {segments:75, radius:0.99});
    meshInstance = new pc.scene.MeshInstance(node, mesh, this.blockerMaterial);
    meshInstance.layer = pc.scene.LAYER_GIZMO;
    meshInstance.updateKey();
    meshInstances.push(meshInstance);
    var model = new pc.scene.Model;
    model.graph = node;
    model.meshInstances = meshInstances;
    return model
  }, createTranslateGizmo:function() {
    var device = this.context.graphicsDevice;
    var node = new pc.scene.GraphNode;
    var meshInstances = this.createAxes(node);
    var coneMesh = pc.scene.procedural.createCone(device, {baseRadius:0.085, peakRadius:0, height:0.3});
    var tipNodes = [new pc.scene.GraphNode, new pc.scene.GraphNode, new pc.scene.GraphNode];
    tipNodes[0].setLocalEulerAngles(0, 0, -90);
    tipNodes[0].setLocalPosition(1.15, 0, 0);
    tipNodes[1].setLocalPosition(0, 1.15, 0);
    tipNodes[2].setLocalEulerAngles(90, 0, 0);
    tipNodes[2].setLocalPosition(0, 0, 1.15);
    var planeMesh = pc.scene.procedural.createPlane(device, {halfExtents:new pc.Vec2(MULTIAXIS_PLANESIZE * 0.5, MULTIAXIS_PLANESIZE * 0.5), widthSegments:1, lengthSegments:1});
    var planeNodes = [new pc.scene.GraphNode, new pc.scene.GraphNode, new pc.scene.GraphNode];
    planeNodes[0].setLocalEulerAngles(90, 0, 0);
    planeNodes[0].setLocalPosition(MULTIAXIS_PLANESIZE * 0.5, MULTIAXIS_PLANESIZE * 0.5, 0);
    planeNodes[1].setLocalEulerAngles(90, 90, 0);
    planeNodes[1].setLocalPosition(0, MULTIAXIS_PLANESIZE * 0.5, MULTIAXIS_PLANESIZE * 0.5);
    planeNodes[2].setLocalPosition(MULTIAXIS_PLANESIZE * 0.5, 0, MULTIAXIS_PLANESIZE * 0.5);
    var materials = this.gizmoMaterials[pc.designer.graphics.GizmoMode.TRANSLATE];
    for(var axis = 0;axis < 3;axis++) {
      node.addChild(planeNodes[axis]);
      meshInstance = new pc.scene.MeshInstance(planeNodes[axis], planeMesh, materials[axis + 3]);
      meshInstance.layer = pc.scene.LAYER_GIZMO;
      meshInstance.updateKey();
      meshInstances.push(meshInstance)
    }
    for(var axis = 0;axis < 3;axis++) {
      node.addChild(tipNodes[axis]);
      var meshInstance = new pc.scene.MeshInstance(tipNodes[axis], coneMesh, materials[axis]);
      meshInstance.layer = pc.scene.LAYER_GIZMO;
      meshInstance.updateKey();
      meshInstances.push(meshInstance)
    }
    var model = new pc.scene.Model;
    model.graph = node;
    model.meshInstances = meshInstances;
    return model
  }, createScaleGizmo:function() {
    var device = this.context.graphicsDevice;
    var node = new pc.scene.GraphNode;
    var meshInstances = this.createAxes(node);
    var mesh = pc.scene.procedural.createBox(device, {halfExtents:new pc.Vec3(0.1, 0.1, 0.1)});
    var materials = this.gizmoMaterials[pc.designer.graphics.GizmoMode.SCALE];
    var centerNode = new pc.scene.GraphNode;
    node.addChild(centerNode);
    var meshInstance = new pc.scene.MeshInstance(centerNode, mesh, materials[3]);
    meshInstance.layer = pc.scene.LAYER_GIZMO;
    meshInstance.updateKey();
    meshInstances.push(meshInstance);
    var nodes = [new pc.scene.GraphNode, new pc.scene.GraphNode, new pc.scene.GraphNode];
    nodes[0].setLocalPosition(1.1, 0, 0);
    nodes[1].setLocalPosition(0, 1.1, 0);
    nodes[2].setLocalPosition(0, 0, 1.1);
    for(var i = 0;i < 3;i++) {
      node.addChild(nodes[i]);
      var meshInstance = new pc.scene.MeshInstance(nodes[i], mesh, materials[i]);
      meshInstance.layer = pc.scene.LAYER_GIZMO;
      meshInstance.updateKey();
      meshInstances.push(meshInstance)
    }
    var model = new pc.scene.Model;
    model.graph = node;
    model.meshInstances = meshInstances;
    return model
  }, render:function(gizmo, transform, activeAxis, cameraTransform) {
    var model;
    if(this.currentGizmo !== gizmo) {
      model = this.gizmos[this.currentGizmo];
      if(this.context.scene.containsModel(model)) {
        this.context.scene.removeModel(model);
        this.context.root.removeChild(model.graph)
      }
      this.currentGizmo = gizmo;
      model = this.gizmos[this.currentGizmo];
      if(!this.context.scene.containsModel(model)) {
        this.context.scene.addModel(model);
        this.context.root.addChild(model.graph)
      }
    }
    if(this.currentGizmo !== -1) {
      model = this.gizmos[this.currentGizmo];
      var root = model.graph;
      root.setPosition(transform.getTranslation());
      root.setEulerAngles(transform.getEulerAngles());
      root.setLocalScale(transform.getScale());
      var meshInstances = model.meshInstances;
      var materials = this.gizmoMaterials[this.currentGizmo];
      for(var i = 0, len = materials.length;i < len;i++) {
        meshInstances[i].material = materials[i]
      }
      this.renders[this.currentGizmo].call(this, transform, cameraTransform, activeAxis)
    }
  }, _setMeshInstanceLayer:function(meshInstance, layer) {
    if(meshInstance.layer !== layer) {
      meshInstance.layer = layer;
      meshInstance.updateKey()
    }
  }, getIndicesOfDisabledGizmoMeshes:function(gizmo) {
    var result = [];
    var gizmo = this.gizmos[gizmo];
    var meshInstances = gizmo.meshInstances;
    for(var i = 0;i < meshInstances.length;i++) {
      if(meshInstances[i].material === this.invisibleMaterial) {
        result.push(i)
      }
    }
    return result
  }, _renderRotateGizmo:function(gizmoTransform, cameraTransform, activeAxis) {
    var gizmoModel = this.gizmos[this.currentGizmo];
    var selectedMaterials = this.selectedMaterials[this.currentGizmo];
    if(activeAxis >= 0 && activeAxis < 3) {
      gizmoModel.meshInstances[activeAxis].material = selectedMaterials[activeAxis]
    }
    var lookDir = gizmoTransform.getTranslation().sub(cameraTransform.getTranslation()).normalize();
    var axes = [gizmoTransform.getX().normalize(), gizmoTransform.getY().normalize(), gizmoTransform.getZ().normalize()];
    for(var i = 0;i < 3;i++) {
      var meshInstance = gizmoModel.meshInstances[i];
      var layer = pc.scene.LAYER_GIZMO;
      if(Math.abs(lookDir.dot(axes[i])) < 0.15) {
        meshInstance.material = this.invisibleMaterial
      }
      this._setMeshInstanceLayer(meshInstance, layer)
    }
  }, _renderTranslateGizmo:function(gizmoTransform, cameraTransform, activeAxis) {
    var gizmoModel = this.gizmos[this.currentGizmo];
    var selectedMaterials = this.selectedMaterials[this.currentGizmo];
    if(activeAxis >= 0) {
      if(activeAxis < 3) {
        gizmoModel.meshInstances[activeAxis].material = selectedMaterials[activeAxis];
        gizmoModel.meshInstances[activeAxis + 6].material = selectedMaterials[activeAxis + 6]
      }else {
        gizmoModel.meshInstances[activeAxis].material = selectedMaterials[activeAxis]
      }
    }
    var cameraPosition = cameraTransform.getTranslation();
    var lookDir = gizmoTransform.getTranslation().sub(cameraPosition).normalize();
    var axes = [gizmoTransform.getX().normalize(), gizmoTransform.getY().normalize(), gizmoTransform.getZ().normalize()];
    for(var i = 0;i < 3;i++) {
      var layer = pc.scene.LAYER_GIZMO;
      var meshInstance1 = gizmoModel.meshInstances[i];
      var meshInstance2 = gizmoModel.meshInstances[i + 6];
      if(Math.abs(lookDir.dot(axes[i])) > 0.99) {
        meshInstance1.material = this.invisibleMaterial;
        meshInstance2.material = this.invisibleMaterial
      }
      this._setMeshInstanceLayer(meshInstance1, layer);
      this._setMeshInstanceLayer(meshInstance2, layer)
    }
    var planes = [gizmoModel.meshInstances[3], gizmoModel.meshInstances[4], gizmoModel.meshInstances[5]];
    var planeAxes = [axes[2], axes[0], axes[1]];
    for(var i = 0;i < 3;i++) {
      var plane = planes[i];
      if(Math.abs(lookDir.dot(planeAxes[i])) < 0.1) {
        plane.material = this.invisibleMaterial
      }else {
        this._setMeshInstanceLayer(plane, pc.scene.LAYER_GIZMO)
      }
    }
    var gizmoGraph = gizmoModel.graph;
    var children = gizmoGraph.getChildren();
    var temp = new pc.Vec3;
    var isUnderZ = temp.cross(lookDir, axes[0]).dot(axes[2]) < 0;
    var isLeftOfX = temp.cross(lookDir, axes[0]).dot(axes[1]) > 0;
    var isLeftOfZ = temp.cross(lookDir, axes[2]).dot(axes[1]) > 0;
    var x, y, z;
    var offset = MULTIAXIS_PLANESIZE * 0.5;
    x = isLeftOfZ ? 1 : -1;
    y = isUnderZ ? -1 : 1;
    children[0].setLocalPosition(x * offset, y * offset, 0);
    y = isUnderZ ? -1 : 1;
    z = isLeftOfX ? -1 : 1;
    children[1].setLocalPosition(0, y * offset, z * offset);
    x = isLeftOfZ ? 1 : -1;
    z = isLeftOfX ? -1 : 1;
    children[2].setLocalPosition(x * offset, 0, z * offset)
  }, _renderScaleGizmo:function(gizmoTransform, cameraTransform, activeAxis) {
    var gizmoModel = this.gizmos[this.currentGizmo];
    var selectedMaterials = this.selectedMaterials[this.currentGizmo];
    if(activeAxis >= 0) {
      if(activeAxis < 3) {
        gizmoModel.meshInstances[activeAxis].material = selectedMaterials[activeAxis];
        gizmoModel.meshInstances[activeAxis + 4].material = selectedMaterials[activeAxis + 4]
      }else {
        gizmoModel.meshInstances[activeAxis].material = selectedMaterials[activeAxis]
      }
    }
    var lookDir = gizmoTransform.getTranslation().sub(cameraTransform.getTranslation()).normalize();
    var axes = [gizmoTransform.getX().normalize(), gizmoTransform.getY().normalize(), gizmoTransform.getZ().normalize()];
    for(var i = 0;i < 3;i++) {
      var layer = pc.scene.LAYER_GIZMO;
      var meshInstance1 = gizmoModel.meshInstances[i];
      var meshInstance2 = gizmoModel.meshInstances[i + 4];
      if(Math.abs(lookDir.dot(axes[i])) > 0.99) {
        meshInstance1.material = this.invisibleMaterial;
        meshInstance2.material = this.invisibleMaterial
      }
      this._setMeshInstanceLayer(meshInstance1, layer);
      this._setMeshInstanceLayer(meshInstance2, layer)
    }
  }, destroy:function() {
    var model = this.gizmos[this.currentGizmo];
    if(this.context.scene.containsModel(model)) {
      this.context.scene.removeModel(model);
      this.context.root.removeChild(model.graph)
    }
    this.currentGizmo = -1
  }};
  return{Gizmo:Gizmo, GizmoMode:{TRANSLATE:0, ROTATE:1, SCALE:2}}
}());pc.extend(pc.designer.graphics, function() {
  var Grid = function(device, size, divisions) {
    var vertexFormat = new pc.gfx.VertexFormat(device, [{semantic:pc.gfx.SEMANTIC_POSITION, components:3, type:pc.gfx.ELEMENTTYPE_FLOAT32}, {semantic:pc.gfx.SEMANTIC_COLOR, components:4, type:pc.gfx.ELEMENTTYPE_UINT8, normalize:true}]);
    var size = size || 140;
    var divisions = divisions || 14;
    var interval = size / divisions;
    var numVerts = (divisions + 1) * 4;
    var gridColor = [136, 136, 136, 255];
    var axisColor = [0, 0, 0, 255];
    var color;
    this.vertexBuffer = new pc.gfx.VertexBuffer(device, vertexFormat, numVerts);
    var vertexBuffer = this.vertexBuffer;
    var iterator = new pc.gfx.VertexIterator(vertexBuffer);
    for(i = -(divisions / 2);i <= divisions / 2;i++) {
      color = i === 0 ? axisColor : gridColor;
      iterator.element[pc.gfx.SEMANTIC_POSITION].set(-size / 2, 0, i * interval);
      iterator.element[pc.gfx.SEMANTIC_COLOR].set(color[0], color[1], color[2], color[3]);
      iterator.next();
      iterator.element[pc.gfx.SEMANTIC_POSITION].set(size / 2, 0, i * interval);
      iterator.element[pc.gfx.SEMANTIC_COLOR].set(color[0], color[1], color[2], color[3]);
      iterator.next();
      iterator.element[pc.gfx.SEMANTIC_POSITION].set(i * interval, 0, -size / 2);
      iterator.element[pc.gfx.SEMANTIC_COLOR].set(color[0], color[1], color[2], color[3]);
      iterator.next();
      iterator.element[pc.gfx.SEMANTIC_POSITION].set(i * interval, 0, size / 2);
      iterator.element[pc.gfx.SEMANTIC_COLOR].set(color[0], color[1], color[2], color[3]);
      if(i !== divisions / 2) {
        iterator.next()
      }
    }
    iterator.end();
    var library = device.getProgramLibrary();
    var shader = library.getProgram("basic", {vertexColors:true, diffuseMapping:false});
    var material = new pc.scene.Material;
    material.shader = shader;
    var mesh = new pc.scene.Mesh;
    mesh.vertexBuffer = vertexBuffer;
    mesh.indexBuffer[0] = null;
    mesh.primitive[0].type = pc.gfx.PRIMITIVE_LINES;
    mesh.primitive[0].base = 0;
    mesh.primitive[0].count = vertexBuffer.getNumVertices();
    mesh.primitive[0].indexed = false;
    var node = new pc.scene.GraphNode;
    node.setName("grid");
    var meshInstance = new pc.scene.MeshInstance(node, mesh, material);
    var model = new pc.scene.Model;
    model.graph = node;
    model.meshInstances = [meshInstance];
    this.model = model
  };
  Grid.prototype = {destroy:function() {
    if(this.vertexBuffer) {
      this.vertexBuffer.destroy();
      this.vertexBuffer = null
    }
  }};
  return{Grid:Grid}
}());pc.extend(pc.designer.graphics, function() {
  function createTextTexture(device, textContext, text) {
    textContext.fillStyle = "rgb(76, 82, 93)";
    textContext.fillRect(0, 0, textContext.canvas.width, textContext.canvas.height);
    textContext.fillStyle = "rgb(184, 189, 197)";
    textContext.fillRect(5, 5, textContext.canvas.width - 10, textContext.canvas.height - 10);
    textContext.fillStyle = "rgb(76, 82, 93)";
    textContext.lineWidth = 2.5;
    textContext.strokeStyle = "black";
    textContext.save();
    textContext.font = "50px Verdana";
    textContext.textAlign = "center";
    textContext.textBaseline = "middle";
    var leftOffset = textContext.canvas.width / 2;
    var topOffset = textContext.canvas.height / 2;
    textContext.strokeText(text, leftOffset, topOffset);
    textContext.fillText(text, leftOffset, topOffset);
    textContext.restore();
    textTexture = new pc.gfx.Texture(device, {format:pc.gfx.PIXELFORMAT_R8_G8_B8});
    textTexture.minFilter = pc.gfx.FILTER_LINEAR_MIPMAP_LINEAR;
    textTexture.magFilter = pc.gfx.FILTER_LINEAR;
    textTexture.addressU = pc.gfx.ADDRESS_CLAMP_TO_EDGE;
    textTexture.addressV = pc.gfx.ADDRESS_CLAMP_TO_EDGE;
    textTexture.maxAnisotropy = device.maxSupportedMaxAnisotropy;
    textTexture.setSource(textContext.canvas);
    return textTexture
  }
  var ViewCube = function(device) {
    var textCanvas = document.createElement("canvas");
    textCanvas.width = 256;
    textCanvas.height = 128;
    var textContext = textCanvas.getContext("2d");
    if(textContext) {
      var lookAts = [{pos:new pc.Vec3(-0.5, 0, 0), target:new pc.Vec3(-1, 0, 0), up:new pc.Vec3(0, -1, 0)}, {pos:new pc.Vec3(0.5, 0, 0), target:new pc.Vec3(1, 0, 0), up:new pc.Vec3(0, -1, 0)}, {pos:new pc.Vec3(0, 0.5, 0), target:new pc.Vec3(0, 1, 0), up:new pc.Vec3(0, 0, 1)}, {pos:new pc.Vec3(0, -0.5, 0), target:new pc.Vec3(0, -1, 0), up:new pc.Vec3(0, 0, 1)}, {pos:new pc.Vec3(0, 0, 0.5), target:new pc.Vec3(0, 0, 1), up:new pc.Vec3(0, -1, 0)}, {pos:new pc.Vec3(0, 0, -0.5), target:new pc.Vec3(0, 0,
      -1), up:new pc.Vec3(0, -1, 0)}];
      this.faces = [{name:"LEFT"}, {name:"RIGHT"}, {name:"TOP"}, {name:"BOTTOM"}, {name:"FRONT"}, {name:"BACK"}];
      for(var i = 0;i < this.faces.length;i++) {
        var texture = createTextTexture(device, textContext, this.faces[i].name);
        var faceMaterial = new pc.scene.BasicMaterial;
        faceMaterial.color = new pc.Color(1, 1, 1, 0.35);
        faceMaterial.colorMap = texture;
        faceMaterial.blendType = pc.scene.BLEND_NORMAL;
        faceMaterial.depthTest = false;
        faceMaterial.depthWrite = false;
        faceMaterial.update();
        this.faces[i].plane = pc.scene.procedural.createPlane(device);
        var lookAt = (new pc.Mat4).setLookAt(lookAts[i].pos, lookAts[i].target, lookAts[i].up);
        var rot = (new pc.Mat4).setFromAxisAngle(pc.Vec3.RIGHT, -90);
        this.faces[i].xform = lookAt.mul(rot)
      }
    }else {
      logERROR("Failed to create 2d Context for viewcube");
      this.faces = []
    }
    this.projMat = (new pc.Mat4).setPerspective(30, 1, 0.1, 10);
    this.viewMat = new pc.Mat4;
    this.tempMat1 = new pc.Mat4;
    this.tempMat2 = new pc.Mat4
  };
  ViewCube.prototype.render = function(transform) {
    var target = device.getRenderTarget();
    device.updateEnd();
    var oldViewport = target.getViewport();
    target.setViewport({x:oldViewport.x + (oldViewport.width - 100), y:oldViewport.y + (oldViewport.height - 100), width:100, height:100});
    device.setRenderTarget(target);
    device.updateBegin();
    var projId = device.scope.resolve("matrix_projection");
    var viewId = device.scope.resolve("matrix_view");
    var viewProjId = device.scope.resolve("matrix_viewProjection");
    var projMat = projId.getValue();
    var viewMat = viewId.getValue();
    var viewProjMat = viewProjId.getValue();
    projId.setValue(this.projMat);
    viewId.setValue(this.viewMat);
    viewProjId.setValue(this.projMat);
    this.tempMat1.copy(viewMat);
    this.tempMat1.data[12] = 0;
    this.tempMat1.data[13] = 0;
    this.tempMat1.data[14] = 0;
    for(var i = 0;i < this.faces.length;i++) {
      this.tempMat2.multiply(this.tempMat1, this.faces[i].xform);
      this.tempMat2.data[14] -= 4;
      this.faces[i].plane.dispatch(this.tempMat2)
    }
    projId.setValue(projMat);
    viewId.setValue(viewMat);
    viewProjId.setValue(viewProjMat);
    device.updateEnd();
    target.setViewport(oldViewport);
    device.updateBegin()
  };
  return{ViewCube:ViewCube}
}());pc.extend(pc.designer, function() {
  var DRAG_SCALE_FACTOR = 0.5;
  var GizmoComponentSystem = function GizmoComponentSystem(context) {
    this.id = "gizmo";
    this.context.systems.add(this.id, this);
    this.ComponentType = pc.designer.GizmoComponent;
    this.DataType = pc.designer.GizmoComponentData;
    this.schema = [{name:"gizmoType", expose:false}, {name:"activeAxis", expose:false}];
    this.picker = new pc.scene.Picker(context.graphicsDevice, 1024, 1024);
    this.gizmoScene = new pc.scene.Scene;
    this.selection = [];
    this.activeGizmo = null;
    this.currentType = pc.designer.GizmoComponentSystem.GizmoType.TRANSLATE;
    this.currentCoordSys = pc.designer.GizmoComponentSystem.GizmoCoordSys.WORLD;
    this.renderable = new pc.designer.graphics.Gizmo(context);
    this.draggingState = null;
    this.snapEnabled = false;
    this.snapEnabledOverride = false;
    this.snapTranslationIncrement = 1;
    this.snapRotationIncrement = 5;
    this.snapScaleIncrement = 1;
    this.hoveredGizmo = {entity:null, axis:-1};
    this.clickedEntity = null;
    this.renders = {};
    this.renders[pc.designer.GizmoComponentSystem.GizmoType.TRANSLATE] = this._renderTranslateGizmo;
    this.renders[pc.designer.GizmoComponentSystem.GizmoType.ROTATE] = this._renderRotateGizmo;
    this.renders[pc.designer.GizmoComponentSystem.GizmoType.SCALE] = this._renderScaleGizmo;
    this.disabledPickerShapes = {};
    pc.fw.ComponentSystem.bind("toolsUpdate", this.onUpdate.bind(this));
    this.bind("remove", this.onRemove.bind(this))
  };
  GizmoComponentSystem = pc.inherits(GizmoComponentSystem, pc.fw.ComponentSystem);
  GizmoComponentSystem.GizmoType = {TRANSLATE:"position", ROTATE:"rotation", SCALE:"scale"};
  GizmoComponentSystem.GizmoCoordSys = {WORLD:"world", LOCAL:"local"};
  pc.extend(GizmoComponentSystem.prototype, {initializeComponentData:function(component, data, properties) {
    this.context.systems.pick.addComponent(component.entity, {});
    component.entity.pick.layer = "gizmo";
    properties = ["gizmoType"];
    GizmoComponentSystem._super.initializeComponentData.call(this, component, data, properties)
  }, onRemove:function(entity, data) {
    this.context.systems.pick.removeComponent(entity)
  }, onUpdate:function(dt) {
    var id, components = this.store;
    for(id in components) {
      if(components.hasOwnProperty(id)) {
        var entity = components[id].entity;
        this.renders[this.currentType].call(this, entity)
      }
    }
  }, _renderTranslateGizmo:function(entity) {
    var position = entity.getPosition();
    var rotation = entity.getRotation();
    var wtm = new pc.Mat4;
    var x, y, z;
    if(this.currentCoordSys === GizmoComponentSystem.GizmoCoordSys.WORLD) {
      wtm.setTRS(position, pc.Quat.IDENTITY, pc.Vec3.ONE)
    }else {
      wtm.setTRS(position, rotation, pc.Vec3.ONE)
    }
    var scaleFactor = this._calculateGizmoScale(position);
    var gizmoScale = (new pc.Mat4).setScale(scaleFactor, scaleFactor, scaleFactor);
    var transform = (new pc.Mat4).mul2(wtm, gizmoScale);
    var shapes = entity.pick.shapes;
    var scale = (new pc.Mat4).setScale(scaleFactor * 1.3, scaleFactor * 0.15, scaleFactor * 0.15);
    var translate = (new pc.Mat4).setTranslate(scaleFactor * 0.65, 0, 0);
    translate.mul2(wtm, translate);
    shapes[0].shape.transform.mul2(translate, scale);
    scale.setScale(scaleFactor * 0.15, scaleFactor * 1.3, scaleFactor * 0.15);
    translate.setTranslate(0, scaleFactor * 0.65, 0);
    translate.mul2(wtm, translate);
    shapes[1].shape.transform.mul2(translate, scale);
    scale.setScale(scaleFactor * 0.15, scaleFactor * 0.15, scaleFactor * 1.3);
    translate.setTranslate(0, 0, scaleFactor * 0.65);
    translate.mul2(wtm, translate);
    shapes[2].shape.transform.mul2(translate, scale);
    var planeSize = 0.3;
    var temp = new pc.Vec3;
    var axes = [transform.getX().normalize(), transform.getY().normalize(), transform.getZ().normalize()];
    var lookDir = transform.getTranslation().sub(this.camera.getPosition()).normalize();
    var isUnderZ = temp.cross(lookDir, axes[0]).dot(axes[2]) < 0;
    var isLeftOfX = temp.cross(lookDir, axes[0]).dot(axes[1]) > 0;
    var isLeftOfZ = temp.cross(lookDir, axes[2]).dot(axes[1]) > 0;
    scale = (new pc.Mat4).setScale(scaleFactor * planeSize, scaleFactor * planeSize, scaleFactor * planeSize * 0.1);
    x = isLeftOfZ ? 1 : -1;
    y = isUnderZ ? -1 : 1;
    translate = (new pc.Mat4).setTranslate(x * scaleFactor * planeSize * 0.5, y * scaleFactor * planeSize * 0.5, 0);
    translate.mul2(wtm, translate);
    shapes[3].shape.transform.mul2(translate, scale);
    scale = (new pc.Mat4).setScale(scaleFactor * planeSize * 0.1, scaleFactor * planeSize, scaleFactor * planeSize);
    y = isUnderZ ? -1 : 1;
    z = isLeftOfX ? -1 : 1;
    translate = (new pc.Mat4).setTranslate(0, y * scaleFactor * planeSize * 0.5, z * scaleFactor * planeSize * 0.5);
    translate.mul2(wtm, translate);
    shapes[4].shape.transform.mul2(translate, scale);
    scale = (new pc.Mat4).setScale(scaleFactor * planeSize, scaleFactor * planeSize * 0.1, scaleFactor * planeSize);
    x = isLeftOfZ ? 1 : -1;
    z = isLeftOfX ? -1 : 1;
    translate = (new pc.Mat4).setTranslate(x * scaleFactor * planeSize * 0.5, 0, z * scaleFactor * planeSize * 0.5);
    translate.mul2(wtm, translate);
    shapes[5].shape.transform.mul2(translate, scale);
    for(var i = 0;i < 6;i++) {
      shapes[i].model.getGraph().getWorldTransform().copy(shapes[i].shape.transform)
    }
    this.renderable.render(pc.designer.graphics.GizmoMode.TRANSLATE, transform, entity.gizmo.activeAxis, this.camera.getWorldTransform());
    for(var i = 0;i < shapes.length;i++) {
      delete this.disabledPickerShapes[shapes[i].shapeName]
    }
    var indices = this.renderable.getIndicesOfDisabledGizmoMeshes(pc.designer.graphics.GizmoMode.TRANSLATE);
    for(var i = 0;i < indices.length;i++) {
      var index = indices[i];
      if(index < shapes.length) {
        this.disabledPickerShapes[shapes[index].shapeName] = true
      }
    }
  }, _renderRotateGizmo:function(entity) {
    var position = entity.getPosition();
    var rotation = entity.getRotation();
    var wtm = new pc.Mat4;
    if(this.currentCoordSys === GizmoComponentSystem.GizmoCoordSys.WORLD) {
      wtm.setTRS(position, pc.Quat.IDENTITY, pc.Vec3.ONE)
    }else {
      wtm.setTRS(position, rotation, pc.Vec3.ONE)
    }
    var scaleFactor = this._calculateGizmoScale(position);
    var gizmoScale = (new pc.Mat4).setScale(scaleFactor, scaleFactor, scaleFactor);
    var shapes = entity.pick.shapes;
    var rotate = (new pc.Mat4).setFromAxisAngle(pc.Vec3.BACK, 90);
    rotate.mul2(wtm, rotate);
    shapes[0].shape.transform.mul2(rotate, gizmoScale);
    shapes[1].shape.transform.mul2(wtm, gizmoScale);
    rotate.setFromAxisAngle(pc.Vec3.RIGHT, 90);
    rotate.mul2(wtm, rotate);
    shapes[2].shape.transform.mul2(rotate, gizmoScale);
    for(var i = 0;i < 3;i++) {
      shapes[i].model.getGraph().getWorldTransform().copy(shapes[i].shape.transform)
    }
    this.renderable.render(pc.designer.graphics.GizmoMode.ROTATE, shapes[1].shape.transform, entity.gizmo.activeAxis, this.camera.getWorldTransform());
    for(var i = 0;i < shapes.length;i++) {
      delete this.disabledPickerShapes[shapes[i].shapeName]
    }
    var indices = this.renderable.getIndicesOfDisabledGizmoMeshes(pc.designer.graphics.GizmoMode.ROTATE);
    for(var i = 0;i < indices.length;i++) {
      var index = indices[i];
      if(index < shapes.length) {
        this.disabledPickerShapes[shapes[index].shapeName] = true
      }
    }
  }, _renderScaleGizmo:function(entity) {
    var position = entity.getPosition();
    var rotation = entity.getRotation();
    var wtm = new pc.Mat4;
    wtm.setTRS(position, rotation, pc.Vec3.ONE);
    var scaleFactor = this._calculateGizmoScale(position);
    var gizmoScale = (new pc.Mat4).setScale(scaleFactor, scaleFactor, scaleFactor);
    var shapes = entity.pick.shapes;
    var scale = (new pc.Mat4).setScale(scaleFactor * 1.1, scaleFactor * 0.15, scaleFactor * 0.15);
    var translate = (new pc.Mat4).setTranslate(scaleFactor * 0.7, 0, 0);
    translate.mul2(wtm, translate);
    shapes[0].shape.transform.mul2(translate, scale);
    scale.setScale(scaleFactor * 0.15, scaleFactor * 1.1, scaleFactor * 0.15);
    translate.setTranslate(0, scaleFactor * 0.7, 0);
    translate.mul2(wtm, translate);
    shapes[1].shape.transform.mul2(translate, scale);
    scale.setScale(scaleFactor * 0.15, scaleFactor * 0.15, scaleFactor * 1.1);
    translate.setTranslate(0, 0, scaleFactor * 0.7);
    translate.mul2(wtm, translate);
    shapes[2].shape.transform.mul2(translate, scale);
    scale.setScale(scaleFactor * 0.3, scaleFactor * 0.3, scaleFactor * 0.3);
    translate.setTranslate(0, 0, 0);
    translate.mul2(wtm, translate);
    shapes[3].shape.transform.mul2(translate, scale);
    for(var i = 0;i < 4;i++) {
      shapes[i].model.getGraph().getWorldTransform().copy(shapes[i].shape.transform)
    }
    var transform = (new pc.Mat4).mul2(wtm, gizmoScale);
    this.renderable.render(pc.designer.graphics.GizmoMode.SCALE, transform, entity.gizmo.activeAxis, this.camera.getWorldTransform());
    for(var i = 0;i < shapes.length;i++) {
      delete this.disabledPickerShapes[shapes[i].shapeName]
    }
    var indices = this.renderable.getIndicesOfDisabledGizmoMeshes(pc.designer.graphics.GizmoMode.SCALE);
    for(var i = 0;i < indices.length;i++) {
      var index = indices[i];
      if(index < shapes.length) {
        this.disabledPickerShapes[shapes[index].shapeName] = true
      }
    }
  }});
  GizmoComponentSystem.prototype.setSelection = function(selection) {
    var i;
    var length;
    length = this.selection.length;
    for(i = 0;i < length;++i) {
      this.deselectEntity(this.selection[i])
    }
    this.selection = selection;
    length = selection.length;
    for(i = 0;i < length;++i) {
      this.selectEntity(this.selection[i])
    }
  };
  GizmoComponentSystem.prototype.setCurrentGizmoType = function(type) {
    this.currentType = type;
    this.activeGizmo.gizmo.gizmoType = this.currentType
  };
  GizmoComponentSystem.prototype.setCurrentGizmoCoordSys = function(coordSys) {
    this.currentCoordSys = coordSys
  };
  GizmoComponentSystem.prototype.setActiveGizmoCoordSys = function(coordSys) {
    this.context.systems.gizmo.setCurrentGizmoCoordSys(coordSys)
  };
  GizmoComponentSystem.prototype.setSnapToClosestIncrement = function(snap) {
    this.snapEnabled = snap
  };
  GizmoComponentSystem.prototype.setTranslationSnapIncrement = function(increment) {
    this.snapTranslationIncrement = increment
  };
  GizmoComponentSystem.prototype.setRotationSnapIncrement = function(increment) {
    this.snapRotationIncrement = increment
  };
  GizmoComponentSystem.prototype.setScalingSnapIncrement = function(increment) {
    this.snapScaleIncrement = increment
  };
  GizmoComponentSystem.prototype.selectEntity = function(entity) {
    if(!entity.gizmo) {
      this.addComponent(entity, {gizmoType:this.currentType});
      this.activeGizmo = entity
    }
  };
  GizmoComponentSystem.prototype.deselectEntity = function(entity) {
    if(entity.gizmo) {
      this.renderable.destroy();
      this.removeComponent(entity);
      this.activeGizmo = null
    }
  };
  GizmoComponentSystem.prototype.setCamera = function(camera) {
    this.camera = camera
  };
  GizmoComponentSystem.prototype.handleUpdateMessage = function(entity, name, value) {
    if(this.hasComponent(entity)) {
      this.entityState[name] = value
    }
  };
  GizmoComponentSystem.prototype.handleMouseDown = function(event) {
    if(event.button === pc.input.MOUSEBUTTON_LEFT) {
      if(this.hoveredGizmo.entity) {
        event.event.preventDefault();
        this.startDrag(this.hoveredGizmo.entity, event.x, event.y, this.hoveredGizmo.axis)
      }
    }
  };
  GizmoComponentSystem.prototype.handleMouseUp = function(event) {
    if(event.button === pc.input.MOUSEBUTTON_LEFT) {
      if(this.draggingState) {
        this.endDrag()
      }
      this.clickedEntity = null
    }
  };
  GizmoComponentSystem.prototype.handleMouseMove = function(event) {
    if(this.draggingState) {
      if(this.draggingState.entity) {
        this.snapEnabledOverride = event.shiftKey;
        this.dragGizmo(event.x, event.y);
        return
      }
    }else {
      if(event.event) {
        var coords = {x:event.x, y:event.element.height - event.y};
        var cameraEntity = this.camera;
        if(cameraEntity) {
          var camera = cameraEntity.camera.camera;
          var vp = camera.getRect();
          var gd = this.context.graphicsDevice;
          var dw = gd.width;
          var dh = gd.height;
          var vpx = vp.x * dw;
          var vpy = vp.y * dh;
          var vpw = vp.width * dw;
          var vph = vp.height * dh;
          if(coords.x >= vpx && coords.x < vpx + vpw && coords.y >= vpy && coords.y < vpy + vph) {
            if(vpw !== this.picker.width || vph !== this.picker.height) {
              this.picker.resize(vpw, vph)
            }
            var gizmoModels = this.context.systems.pick.getLayerModels("gizmo");
            if(gizmoModels) {
              for(var i = 0;i < gizmoModels.length;i++) {
                this.gizmoScene.addModel(gizmoModels[i])
              }
              this.picker.prepare(camera, this.gizmoScene);
              var selection = this.picker.getSelection({x:coords.x - vpx, y:coords.y - vpy});
              var idx = -1;
              if(selection.length > 0) {
                var idx = -1;
                var shapes = selection[0]._entity.pick.shapes;
                for(var i = 0;i < shapes.length;i++) {
                  if(this.disabledPickerShapes[shapes[i].shapeName]) {
                    continue
                  }
                  if(selection[0] === shapes[i].model.meshInstances[0]) {
                    if(shapes[i].shapeName === "X") {
                      idx = 0
                    }else {
                      if(shapes[i].shapeName === "Y") {
                        idx = 1
                      }else {
                        if(shapes[i].shapeName === "Z") {
                          idx = 2
                        }else {
                          if(shapes[i].shapeName === "XY" || shapes[i].shapeName === "C") {
                            idx = 3
                          }else {
                            if(shapes[i].shapeName === "YZ") {
                              idx = 4
                            }else {
                              if(shapes[i].shapeName === "ZX") {
                                idx = 5
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              if(idx >= 0) {
                this.hoveredGizmo = {entity:selection[0]._entity, axis:idx};
                if(this.hoveredGizmo.entity) {
                  this.hoveredGizmo.entity.gizmo.activeAxis = idx
                }
              }else {
                if(this.hoveredGizmo.entity && this.hoveredGizmo.entity.gizmo) {
                  this.hoveredGizmo.entity.gizmo.activeAxis = -1
                }
                this.hoveredGizmo = {entity:null, axis:-1}
              }
              for(var i = 0;i < gizmoModels.length;i++) {
                this.gizmoScene.removeModel(gizmoModels[i])
              }
            }
          }
        }
      }
    }
  };
  GizmoComponentSystem.prototype.startDrag = function(entity, x, y, axis) {
    var original = entity["_$" + this.currentType];
    if(!original) {
      logERROR("Transform Components ('_$position', '_$rotation', '_$scale') not found on entity object, Gizmo Component will not work.")
    }
    this.draggingState = {startX:x, startY:y, type:this.currentType, axis:axis, entity:entity, originalTransform:entity.getWorldTransform().clone(), original:new pc.Vec3(original[0], original[1], original[2]), current:new pc.Vec3(original[0], original[1], original[2])}
  };
  GizmoComponentSystem.prototype.dragGizmo = function(x, y) {
    switch(this.currentType) {
      case GizmoComponentSystem.GizmoType.TRANSLATE:
        this._dragTranslateStyleControl(x, y, this.snapTranslationIncrement);
        break;
      case GizmoComponentSystem.GizmoType.ROTATE:
        this._dragRotateStyleControl(x, y, this.snapRotationIncrement);
        break;
      case GizmoComponentSystem.GizmoType.SCALE:
        this._dragScaleStyleControl(x, y, this.snapScaleIncrement);
        break
    }
  };
  GizmoComponentSystem.prototype.endDrag = function() {
    var undoable = true;
    var newValue = this.draggingState.current;
    var oldValue = this.draggingState.original;
    pc.designer.api.setEntityTransformComponent(this.draggingState.entity, this.draggingState.type, newValue, undoable, oldValue);
    this.draggingState = null
  };
  GizmoComponentSystem.prototype._isSnapEnabled = function() {
    return this.snapEnabled !== this.snapEnabledOverride
  };
  GizmoComponentSystem.prototype._dragTranslateStyleControl = function(x, y, snapIncrement) {
    var cameraEntity = this.camera;
    var entityWtm = this.draggingState.originalTransform;
    var currentNearClipCoord = this._screenToNearClipCoord(x, y);
    var initialNearClipCoord = this._screenToNearClipCoord(this.draggingState.startX, this.draggingState.startY);
    var refWorld = this.currentCoordSys === GizmoComponentSystem.GizmoCoordSys.WORLD;
    var axes = [];
    if(refWorld) {
      axes[0] = pc.Vec3.RIGHT;
      axes[1] = pc.Vec3.UP;
      axes[2] = pc.Vec3.BACK
    }else {
      axes[0] = entityWtm.getX().normalize();
      axes[1] = entityWtm.getY().normalize();
      axes[2] = entityWtm.getZ().normalize()
    }
    var planeNormal;
    var lookDir = cameraEntity.forward;
    var axis = this.draggingState.axis;
    if(axis == 0) {
      planeNormal = Math.abs(axes[1].dot(lookDir)) > Math.abs(axes[2].dot(lookDir)) ? axes[1] : axes[2]
    }else {
      if(axis == 1) {
        planeNormal = Math.abs(axes[0].dot(lookDir)) > Math.abs(axes[2].dot(lookDir)) ? axes[0] : axes[2]
      }else {
        if(axis == 2) {
          planeNormal = Math.abs(axes[0].dot(lookDir)) > Math.abs(axes[1].dot(lookDir)) ? axes[0] : axes[1]
        }else {
          if(axis == 3) {
            planeNormal = axes[2]
          }else {
            if(axis == 4) {
              planeNormal = axes[0]
            }else {
              if(axis == 5) {
                planeNormal = axes[1]
              }
            }
          }
        }
      }
    }
    var entityPosition = entityWtm.getTranslation();
    var plane = new pc.shape.Plane(entityPosition, planeNormal);
    var eyePosition = cameraEntity.getPosition();
    if(cameraEntity.camera.projection === pc.scene.Projection.PERSPECTIVE) {
      var currentIntersection = plane.intersectPosition(eyePosition, currentNearClipCoord);
      var initialIntersection = plane.intersectPosition(eyePosition, initialNearClipCoord)
    }else {
      var temp = currentNearClipCoord.clone().add(lookDir);
      var currentIntersection = plane.intersectPosition(currentNearClipCoord, temp);
      temp.add2(initialNearClipCoord, lookDir);
      var initialIntersection = plane.intersectPosition(initialNearClipCoord, temp)
    }
    var translate = currentIntersection.clone().sub(initialIntersection);
    if(axis <= 2) {
      translate.project(axes[axis])
    }
    if(this._isSnapEnabled() && snapIncrement > 0) {
      if(axis <= 2) {
        var amount = translate.length();
        if(amount > 0) {
          var scale = Math.round(amount / snapIncrement) * snapIncrement / amount;
          translate.scale(scale)
        }
      }else {
        var horizontal, vertical;
        switch(axis) {
          case 3:
            horizontal = axes[0];
            vertical = axes[1];
            break;
          case 4:
            horizontal = axes[1];
            vertical = axes[2];
            break;
          case 5:
            horizontal = axes[0];
            vertical = axes[2];
            break
        }
        var h = translate.clone().project(horizontal);
        var amount = h.length();
        if(amount > 0) {
          h.scale(Math.round(amount / snapIncrement) * snapIncrement / amount)
        }
        var v = translate.clone().project(vertical);
        amount = v.length();
        if(amount > 0) {
          v.scale(Math.round(amount / snapIncrement) * snapIncrement / amount)
        }
        translate.add2(h, v)
      }
    }
    var undoable = false;
    var updatedTransform = (new pc.Mat4).setTranslate(translate.x, translate.y, translate.z).mul(this.draggingState.originalTransform);
    var inverseParentWtm = this.draggingState.entity.getParent().getWorldTransform().clone().invert();
    updatedTransform.mul2(inverseParentWtm, updatedTransform);
    var newValue = updatedTransform.getTranslation();
    this.draggingState.current = newValue;
    pc.designer.api.setEntityTransformComponent(this.draggingState.entity, GizmoComponentSystem.GizmoType.TRANSLATE, newValue, undoable)
  };
  GizmoComponentSystem.prototype._dragScaleStyleControl = function(x, y, snapIncrement) {
    var cameraEntity = this.camera;
    var entityWtm = this.draggingState.originalTransform;
    var currentNearClipCoord = this._screenToNearClipCoord(x, y);
    var initialNearClipCoord = this._screenToNearClipCoord(this.draggingState.startX, this.draggingState.startY);
    var axes = [];
    axes[0] = entityWtm.getX().normalize();
    axes[1] = entityWtm.getY().normalize();
    axes[2] = entityWtm.getZ().normalize();
    var planeNormal;
    var lookDir = cameraEntity.forward;
    var axis = this.draggingState.axis;
    if(axis == 0) {
      planeNormal = Math.abs(axes[1].dot(lookDir)) > Math.abs(axes[2].dot(lookDir)) ? axes[1] : axes[2]
    }else {
      if(axis == 1) {
        planeNormal = Math.abs(axes[0].dot(lookDir)) > Math.abs(axes[2].dot(lookDir)) ? axes[0] : axes[2]
      }else {
        if(axis == 2) {
          planeNormal = Math.abs(axes[0].dot(lookDir)) > Math.abs(axes[1].dot(lookDir)) ? axes[0] : axes[1]
        }else {
          if(axis == 3) {
            planeNormal = lookDir.clone().scale(-1)
          }
        }
      }
    }
    var entityPosition = entityWtm.getTranslation();
    var plane = new pc.shape.Plane(entityPosition, planeNormal);
    var eyePosition = cameraEntity.getPosition();
    if(cameraEntity.camera.projection === pc.scene.Projection.PERSPECTIVE) {
      var currentIntersection = plane.intersectPosition(eyePosition, currentNearClipCoord);
      var initialIntersection = plane.intersectPosition(eyePosition, initialNearClipCoord)
    }else {
      var temp = currentNearClipCoord.clone().add(lookDir);
      var currentIntersection = plane.intersectPosition(currentNearClipCoord, temp);
      temp.add2(initialNearClipCoord, lookDir);
      var initialIntersection = plane.intersectPosition(initialNearClipCoord, temp)
    }
    var scale = currentIntersection.clone().sub(initialIntersection);
    var axisToProjectOn;
    if(axis == 3) {
      var inverseCameraWtm = cameraEntity.getWorldTransform().clone().invert();
      inverseCameraWtm.transformVector(scale, scale);
      axisToProjectOn = this.draggingState.original.clone().normalize()
    }else {
      axisToProjectOn = axes[axis]
    }
    scale.project(axisToProjectOn);
    if(axis < 3) {
      var entityRotation = this.draggingState.entity.getRotation();
      var inverseEntityWtm = (new pc.Mat4).setTRS(entityPosition, entityRotation, pc.Vec3.ONE).invert();
      inverseEntityWtm.transformVector(scale, scale)
    }
    if(this._isSnapEnabled() && snapIncrement > 0) {
      if(axis < 3) {
        var amount = scale.length();
        if(amount > 0) {
          scale.scale(Math.round(amount / snapIncrement) * snapIncrement / amount)
        }
      }else {
        for(var i = 0;i < 3;i++) {
          scale.data[i] = Math.round(scale.data[i] / snapIncrement) * snapIncrement
        }
      }
    }
    var undoable = false;
    var newValue = this.draggingState.original.clone().add(scale);
    this.draggingState.current = newValue;
    pc.designer.api.setEntityTransformComponent(this.draggingState.entity, GizmoComponentSystem.GizmoType.SCALE, newValue, undoable)
  };
  GizmoComponentSystem.prototype._dragRotateStyleControl = function(x, y, snapIncrement) {
    var currentNearClipCoord = this._screenToNearClipCoord(x, y);
    var initialNearClipCoord = this._screenToNearClipCoord(this.draggingState.startX, this.draggingState.startY);
    var cameraEntity = this.camera;
    var eyePosition = cameraEntity.getPosition();
    var lookDir = cameraEntity.forward;
    var entityWtm = this.draggingState.originalTransform;
    var temp = new pc.Vec3;
    var refWorld = this.currentCoordSys === GizmoComponentSystem.GizmoCoordSys.WORLD;
    var axes = [];
    if(refWorld) {
      axes[0] = pc.Vec3.RIGHT;
      axes[1] = pc.Vec3.UP;
      axes[2] = pc.Vec3.BACK
    }else {
      axes[0] = entityWtm.getX().normalize();
      axes[1] = entityWtm.getY().normalize();
      axes[2] = entityWtm.getZ().normalize()
    }
    var entityPosition = entityWtm.getTranslation();
    var planePoint = entityPosition;
    var planeNormal = axes[this.draggingState.axis];
    var plane = new pc.shape.Plane(planePoint, planeNormal);
    if(cameraEntity.camera.projection === pc.scene.Projection.PERSPECTIVE) {
      var currentIntersection = plane.intersectPosition(eyePosition, currentNearClipCoord);
      var initialIntersection = plane.intersectPosition(eyePosition, initialNearClipCoord)
    }else {
      temp.add2(currentNearClipCoord, lookDir);
      var currentIntersection = plane.intersectPosition(currentNearClipCoord, temp);
      temp.add2(initialNearClipCoord, lookDir);
      var initialIntersection = plane.intersectPosition(initialNearClipCoord, temp)
    }
    var centerToInitial = initialIntersection.clone().sub(entityPosition).normalize();
    var centerToCurrent = currentIntersection.clone().sub(entityPosition).normalize();
    var angle = Math.acos(centerToInitial.dot(centerToCurrent)) * pc.math.RAD_TO_DEG;
    var cross = temp.cross(centerToInitial, centerToCurrent);
    if(cross.dot(planeNormal) < 0) {
      angle = -angle
    }
    if(this._isSnapEnabled() && snapIncrement > 0) {
      angle = Math.round(angle / snapIncrement) * snapIncrement
    }
    var entity = this.draggingState.entity;
    var rot = (new pc.Mat4).setFromAxisAngle(planeNormal, angle);
    var updatedTransform = (new pc.Mat4).mul2(rot, entityWtm);
    var inverseParentWtm = entity.getParent().getWorldTransform().clone().invert();
    updatedTransform.mul2(inverseParentWtm, updatedTransform);
    var newValue = updatedTransform.getEulerAngles();
    var undoable = false;
    this.draggingState.current = newValue;
    pc.designer.api.setEntityTransformComponent(entity, GizmoComponentSystem.GizmoType.ROTATE, newValue, undoable)
  };
  GizmoComponentSystem.prototype._calculateGizmoScale = function(position) {
    var scale = 1;
    var cameraEntity = this.camera;
    var cameraTransform = cameraEntity.getWorldTransform();
    if(cameraEntity.camera.projection === pc.scene.Projection.PERSPECTIVE) {
      var fov = cameraEntity.camera.fov;
      var cameraPosition = cameraEntity.getPosition();
      var distance = new pc.Vec3;
      var denom = 0;
      var width = 1024;
      var height = 768;
      distance.sub2(position, cameraPosition);
      distance = -distance.dot(cameraTransform.getZ());
      denom = Math.sqrt(width * width + height * height) * Math.tan(fov * pc.math.DEG_TO_RAD);
      scale = Math.max(1.0E-4, distance / denom * 150)
    }else {
      var vwy = cameraEntity.camera.orthoHeight;
      scale = vwy / 3
    }
    return scale
  };
  GizmoComponentSystem.prototype._screenToNearClipCoord = function(x, y) {
    var cameraEntity = this.camera;
    var camera = cameraEntity.camera.camera;
    var vp = camera.getRect();
    var gd = this.context.graphicsDevice;
    var dw = gd.width;
    var dh = gd.height;
    var vpx = vp.x * dw;
    var vpy = vp.y * dh;
    var vpw = vp.width * dw;
    var vph = vp.height * dh;
    var nearClip = cameraEntity.camera.nearClip;
    var viewWindow = new pc.Vec2;
    switch(cameraEntity.camera.projection) {
      case pc.scene.Projection.ORTHOGRAPHIC:
        viewWindow.x = cameraEntity.camera.orthoHeight * cameraEntity.camera.aspectRatio;
        viewWindow.y = cameraEntity.camera.orthoHeight;
        break;
      case pc.scene.Projection.PERSPECTIVE:
        var fov = cameraEntity.camera.fov;
        viewWindow.y = nearClip * Math.tan(fov * 0.5 * Math.PI / 180);
        viewWindow.x = viewWindow.y * vpw / vph;
        break;
      default:
        break
    }
    var eye = cameraEntity.getPosition().clone();
    var lookDir = cameraEntity.forward.scale(nearClip);
    var scaleX = viewWindow.x * ((vpw - x) / vpw * 2 - 1);
    var xOffset = cameraEntity.right.scale(-scaleX);
    var scaleY = viewWindow.y * ((vph - y) / vph * 2 - 1);
    var yOffset = cameraEntity.up.scale(scaleY);
    return eye.add(lookDir).add(xOffset).add(yOffset)
  };
  return{GizmoComponentSystem:GizmoComponentSystem}
}());pc.extend(pc.designer, function() {
  var DRAG_SCALE_FACTOR = 0.5;
  var GizmoComponent = function GizmoComponent(context) {
    this.inits = {};
    this.inits[pc.designer.GizmoComponentSystem.GizmoType.TRANSLATE] = this._initTranslateGizmo;
    this.inits[pc.designer.GizmoComponentSystem.GizmoType.ROTATE] = this._initRotateGizmo;
    this.inits[pc.designer.GizmoComponentSystem.GizmoType.SCALE] = this._initScaleGizmo;
    this.bind("set_gizmoType", this.onSetGizmoType.bind(this))
  };
  GizmoComponent = pc.inherits(GizmoComponent, pc.fw.Component);
  GizmoComponent.GizmoType = {TRANSLATE:"position", ROTATE:"rotation", SCALE:"scale"};
  GizmoComponent.GizmoCoordSys = {WORLD:"world", LOCAL:"local"};
  pc.extend(GizmoComponent.prototype, {onSetGizmoType:function(name, oldValue, newValue) {
    this.entity.pick.deleteShapes();
    this.inits[newValue].call(this)
  }, _initTranslateGizmo:function() {
    this.entity.pick.addShape(new pc.shape.Box, "X");
    this.entity.pick.addShape(new pc.shape.Box, "Y");
    this.entity.pick.addShape(new pc.shape.Box, "Z");
    this.entity.pick.addShape(new pc.shape.Box, "XY");
    this.entity.pick.addShape(new pc.shape.Box, "YZ");
    this.entity.pick.addShape(new pc.shape.Box, "ZX")
  }, _initRotateGizmo:function() {
    var iradius = 0.1;
    var oradius = 1;
    this.entity.pick.addShape(new pc.shape.Torus(new pc.Mat4, iradius, oradius), "X");
    this.entity.pick.addShape(new pc.shape.Torus(new pc.Mat4, iradius, oradius), "Y");
    this.entity.pick.addShape(new pc.shape.Torus(new pc.Mat4, iradius, oradius), "Z")
  }, _initScaleGizmo:function() {
    this.entity.pick.addShape(new pc.shape.Box, "X");
    this.entity.pick.addShape(new pc.shape.Box, "Y");
    this.entity.pick.addShape(new pc.shape.Box, "Z");
    this.entity.pick.addShape(new pc.shape.Box, "C")
  }});
  return{GizmoComponent:GizmoComponent}
}());pc.extend(pc.designer, function() {
  GizmoComponentData = function() {
    this.gizmoType = pc.designer.GizmoComponentSystem.GizmoType.TRANSLATE;
    this.activeAxis = -1
  };
  GizmoComponentData = pc.inherits(GizmoComponentData, pc.fw.ComponentData);
  return{GizmoComponentData:GizmoComponentData}
}());pc.extend(pc.fw, function() {
  var LiveLinkSelectionUpdatedMessage = function(guids) {
    this.type = pc.fw.LiveLinkMessageType.SELECTION_UPDATED;
    this.content = {guids:guids}
  };
  LiveLinkSelectionUpdatedMessage = pc.inherits(LiveLinkSelectionUpdatedMessage, pc.fw.LiveLinkMessage);
  pc.fw.LiveLinkMessage.register("SELECTION_UPDATED");
  return{LiveLinkSelectionUpdatedMessage:LiveLinkSelectionUpdatedMessage}
}());pc.extend(pc.fw, function() {
  var LiveLinkUpdateDesignerSettings = function(settings) {
    this.type = pc.fw.LiveLinkMessageType.UPDATE_DESIGNER_SETTINGS;
    this.content = {settings:settings}
  };
  LiveLinkUpdateDesignerSettings = pc.inherits(LiveLinkUpdateDesignerSettings, pc.fw.LiveLinkMessage);
  pc.fw.LiveLinkMessage.register("UPDATE_DESIGNER_SETTINGS");
  return{LiveLinkUpdateDesignerSettings:LiveLinkUpdateDesignerSettings}
}());
